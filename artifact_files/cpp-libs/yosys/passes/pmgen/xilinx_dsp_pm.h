// Generated by pmgen.py from passes/pmgen/xilinx_dsp.pmg

struct xilinx_dsp_pm {
  Module *module;
  SigMap sigmap;
  std::function<void()> on_accept;
  bool setup_done;
  bool generate_mode;
  int accept_cnt;

  uint32_t rngseed;
  int rng(unsigned int n) {
    rngseed ^= rngseed << 13;
    rngseed ^= rngseed >> 17;
    rngseed ^= rngseed << 5;
    return rngseed % n;
  }

  typedef std::tuple<> index_0_key_type;
  typedef std::tuple<Cell*> index_0_value_type;
  dict<index_0_key_type, vector<index_0_value_type>> index_0;
  typedef std::tuple<SigSpec> index_3_key_type;
  typedef std::tuple<Cell*, IdString, IdString> index_3_value_type;
  dict<index_3_key_type, vector<index_3_value_type>> index_3;
  typedef std::tuple<SigBit> index_9_key_type;
  typedef std::tuple<Cell*, IdString> index_9_value_type;
  dict<index_9_key_type, vector<index_9_value_type>> index_9;
  typedef std::tuple<SigSpec, SigSpec> index_12_key_type;
  typedef std::tuple<Cell*, IdString> index_12_value_type;
  dict<index_12_key_type, vector<index_12_value_type>> index_12;
  typedef std::tuple<SigSpec> index_14_key_type;
  typedef std::tuple<Cell*, Const> index_14_value_type;
  dict<index_14_key_type, vector<index_14_value_type>> index_14;
  typedef std::tuple<SigBit> index_18_key_type;
  typedef std::tuple<Cell*, int> index_18_value_type;
  dict<index_18_key_type, vector<index_18_value_type>> index_18;
  typedef std::tuple<SigSpec> index_20_key_type;
  typedef std::tuple<Cell*, IdString, bool> index_20_value_type;
  dict<index_20_key_type, vector<index_20_value_type>> index_20;
  typedef std::tuple<SigSpec, SigSpec> index_22_key_type;
  typedef std::tuple<Cell*, IdString, bool> index_22_value_type;
  dict<index_22_key_type, vector<index_22_value_type>> index_22;
  typedef std::tuple<SigBit> index_26_key_type;
  typedef std::tuple<Cell*, IdString, int, IdString, bool> index_26_value_type;
  dict<index_26_key_type, vector<index_26_value_type>> index_26;
  typedef std::tuple<SigBit> index_28_key_type;
  typedef std::tuple<Cell*, IdString, int, IdString, bool> index_28_value_type;
  dict<index_28_key_type, vector<index_28_value_type>> index_28;
  typedef std::tuple<SigBit> index_30_key_type;
  typedef std::tuple<Cell*, int> index_30_value_type;
  dict<index_30_key_type, vector<index_30_value_type>> index_30;
  dict<SigBit, pool<Cell*>> sigusers;
  pool<Cell*> blacklist_cells;
  pool<Cell*> autoremove_cells;
  dict<Cell*,int> rollback_cache;
  int rollback;

  struct state_xilinx_dsp_pack_t {
    SigSpec argD;
    SigSpec argQ;
    SigBit clock;
    Cell* dsp;
    Cell* ff;
    Cell* ffA1;
    Cell* ffA1cemux;
    bool ffA1cepol;
    Cell* ffA1rstmux;
    Cell* ffA2;
    Cell* ffA2cemux;
    bool ffA2cepol;
    Cell* ffA2rstmux;
    Cell* ffAD;
    Cell* ffADcemux;
    bool ffADcepol;
    Cell* ffADrstmux;
    bool ffADrstpol;
    bool ffArstpol;
    Cell* ffB1;
    Cell* ffB1cemux;
    bool ffB1cepol;
    Cell* ffB1rstmux;
    Cell* ffB2;
    Cell* ffB2cemux;
    bool ffB2cepol;
    Cell* ffB2rstmux;
    bool ffBrstpol;
    Cell* ffD;
    Cell* ffDcemux;
    bool ffDcepol;
    Cell* ffDrstmux;
    bool ffDrstpol;
    Cell* ffM;
    Cell* ffMcemux;
    bool ffMcepol;
    Cell* ffMrstmux;
    bool ffMrstpol;
    Cell* ffP;
    Cell* ffPcemux;
    bool ffPcepol;
    Cell* ffPrstmux;
    bool ffPrstpol;
    Cell* ffcemux;
    bool ffcepol;
    int ffoffset;
    Cell* ffrstmux;
    bool ffrstpol;
    Cell* overflow;
    Cell* postAdd;
    IdString postAddAB;
    Cell* postAddMux;
    IdString postAddMuxAB;
    Cell* preAdd;
    SigSpec sigA;
    SigSpec sigB;
    SigSpec sigC;
    SigSpec sigD;
    SigSpec sigM;
    SigSpec sigP;
  } st_xilinx_dsp_pack;

  struct udata_xilinx_dsp_pack_t {
    Cell* dff;
    SigSpec dffD;
    SigSpec dffQ;
    Cell* dffcemux;
    bool dffcepol;
    SigBit dffclock;
    Cell* dffrstmux;
    bool dffrstpol;
  } ud_xilinx_dsp_pack;

  IdString id_b_A{"\\A"};
  IdString id_b_ADREG{"\\ADREG"};
  IdString id_b_AREG{"\\AREG"};
  IdString id_b_B{"\\B"};
  IdString id_b_BREG{"\\BREG"};
  IdString id_b_C{"\\C"};
  IdString id_b_CLK{"\\CLK"};
  IdString id_b_CLK_POLARITY{"\\CLK_POLARITY"};
  IdString id_b_D{"\\D"};
  IdString id_b_DREG{"\\DREG"};
  IdString id_b_DSP48E1{"\\DSP48E1"};
  IdString id_b_INMODE{"\\INMODE"};
  IdString id_b_MREG{"\\MREG"};
  IdString id_b_OPMODE{"\\OPMODE"};
  IdString id_b_P{"\\P"};
  IdString id_b_PREG{"\\PREG"};
  IdString id_b_Q{"\\Q"};
  IdString id_b_S{"\\S"};
  IdString id_b_USE_DPORT{"\\USE_DPORT"};
  IdString id_b_USE_MULT{"\\USE_MULT"};
  IdString id_b_USE_PATTERN_DETECT{"\\USE_PATTERN_DETECT"};
  IdString id_b_Y{"\\Y"};
  IdString id_b_init{"\\init"};
  IdString id_b_keep{"\\keep"};
  IdString id_d_add{"$add"};
  IdString id_d_dff{"$dff"};
  IdString id_d_ge{"$ge"};
  IdString id_d_mul{"$mul"};
  IdString id_d_mux{"$mux"};

  void add_siguser(const SigSpec &sig, Cell *cell) {
    for (auto bit : sigmap(sig)) {
      if (bit.wire == nullptr) continue;
      sigusers[bit].insert(cell);
    }
  }

  void blacklist(Cell *cell) {
    if (cell != nullptr && blacklist_cells.insert(cell).second) {
      auto ptr = rollback_cache.find(cell);
      if (ptr == rollback_cache.end()) return;
      int rb = ptr->second;
      if (rollback == 0 || rollback > rb)
        rollback = rb;
    }
  }

  void autoremove(Cell *cell) {
    if (cell != nullptr) {
      autoremove_cells.insert(cell);
      blacklist(cell);
    }
  }

  SigSpec port(Cell *cell, IdString portname) {
    return sigmap(cell->getPort(portname));
  }

  SigSpec port(Cell *cell, IdString portname, const SigSpec& defval) {
    return sigmap(cell->connections_.at(portname, defval));
  }

  Const param(Cell *cell, IdString paramname) {
    return cell->getParam(paramname);
  }

  Const param(Cell *cell, IdString paramname, const Const& defval) {
    return cell->parameters.at(paramname, defval);
  }

  int nusers(const SigSpec &sig) {
    pool<Cell*> users;
    for (auto bit : sigmap(sig))
      for (auto user : sigusers[bit])
        users.insert(user);
    return GetSize(users);
  }

  xilinx_dsp_pm(Module *module, const vector<Cell*> &cells) :
      module(module), sigmap(module), setup_done(false), generate_mode(false), rngseed(12345678) {
    setup(cells);
  }

  xilinx_dsp_pm(Module *module) :
      module(module), sigmap(module), setup_done(false), generate_mode(false), rngseed(12345678) {
  }

  void setup(const vector<Cell*> &cells) {
    ud_xilinx_dsp_pack.dff = nullptr;
    ud_xilinx_dsp_pack.dffD = SigSpec();
    ud_xilinx_dsp_pack.dffQ = SigSpec();
    ud_xilinx_dsp_pack.dffcemux = nullptr;
    ud_xilinx_dsp_pack.dffcepol = bool();
    ud_xilinx_dsp_pack.dffclock = SigBit();
    ud_xilinx_dsp_pack.dffrstmux = nullptr;
    ud_xilinx_dsp_pack.dffrstpol = bool();
    log_assert(!setup_done);
    setup_done = true;
    for (auto port : module->ports)
      add_siguser(module->wire(port), nullptr);
    for (auto cell : module->cells())
      for (auto &conn : cell->connections())
        add_siguser(conn.second, cell);
    for (auto cell : cells) {
      do {
        Cell *dsp = cell;
        index_0_value_type value;
        std::get<0>(value) = cell;
        if (!(dsp->type.in(id_b_DSP48E1))) continue;
        index_0_key_type key;
        index_0[key].push_back(value);
      } while (0);
      do {
        Cell *preAdd = cell;
        index_3_value_type value;
        std::get<0>(value) = cell;
        if (!(preAdd->type.in(id_d_add))) continue;
        if (!(GetSize(port(preAdd, id_b_Y)) <= 25)) continue;
        if (!(nusers(port(preAdd, id_b_Y)) == 2)) continue;
        vector<IdString> _pmg_choices_AB = {id_b_A, id_b_B};
        for (const IdString &AB : _pmg_choices_AB) {
        std::get<1>(value) = AB;
        if (!(GetSize(port(preAdd, AB)) <= 30)) continue;
        IdString &BA = std::get<2>(value);
        BA = (AB == id_b_A ? id_b_B : id_b_A);
        if (!(GetSize(port(preAdd, BA)) <= 25)) continue;
        index_3_key_type key;
        std::get<0>(key) = port(preAdd, id_b_Y);
        index_3[key].push_back(value);
        }
      } while (0);
      do {
        Cell *postAdd = cell;
        index_9_value_type value;
        std::get<0>(value) = cell;
        if (!(postAdd->type.in(id_d_add))) continue;
        if (!(GetSize(port(postAdd, id_b_Y)) <= 48)) continue;
        vector<IdString> _pmg_choices_AB = {id_b_A, id_b_B};
        for (const IdString &AB : _pmg_choices_AB) {
        std::get<1>(value) = AB;
        if (!(nusers(port(postAdd, AB)) <= 3)) continue;
        index_9_key_type key;
        std::get<0>(key) = port(postAdd, AB)[0];
        index_9[key].push_back(value);
        }
      } while (0);
      do {
        Cell *postAddMux = cell;
        index_12_value_type value;
        std::get<0>(value) = cell;
        if (!(postAddMux->type.in(id_d_mux))) continue;
        if (!(nusers(port(postAddMux, id_b_Y)) == 2)) continue;
        vector<IdString> _pmg_choices_AB = {id_b_A, id_b_B};
        for (const IdString &AB : _pmg_choices_AB) {
        std::get<1>(value) = AB;
        index_12_key_type key;
        std::get<0>(key) = port(postAddMux, AB);
        std::get<1>(key) = port(postAddMux, id_b_Y);
        index_12[key].push_back(value);
        }
      } while (0);
      do {
        Cell *overflow = cell;
        index_14_value_type value;
        std::get<0>(value) = cell;
        if (!(overflow->type.in(id_d_ge))) continue;
        if (!(GetSize(port(overflow, id_b_Y)) <= 48)) continue;
        if (!(port(overflow, id_b_B).is_fully_const())) continue;
        Const &B = std::get<1>(value);
        B = port(overflow, id_b_B).as_const();
        if (!(std::count(B.bits.begin(), B.bits.end(), State::S1) == 1)) continue;
        index_14_key_type key;
        std::get<0>(key) = port(overflow, id_b_A);
        index_14[key].push_back(value);
      } while (0);
      do {
        Cell *ff = cell;
        index_18_value_type value;
        std::get<0>(value) = cell;
        if (!(ff->type.in(id_d_dff))) continue;
        if (!(param(ff, id_b_CLK_POLARITY).as_bool())) continue;
        int &offset = std::get<1>(value);
        for (offset = 0; offset < GetSize(port(ff, id_b_D)); offset++) {
        index_18_key_type key;
        std::get<0>(key) = port(ff, id_b_Q)[offset];
        index_18[key].push_back(value);
        }
      } while (0);
      do {
        Cell *ffrstmux = cell;
        index_20_value_type value;
        std::get<0>(value) = cell;
        if (!(ffrstmux->type.in(id_d_mux))) continue;
        vector<IdString> _pmg_choices_BA = {id_b_B, id_b_A};
        for (const IdString &BA : _pmg_choices_BA) {
        std::get<1>(value) = BA;
        if (!(port(ffrstmux, BA).is_fully_zero())) continue;
        bool &pol = std::get<2>(value);
        pol = (BA == id_b_B);
        index_20_key_type key;
        std::get<0>(key) = port(ffrstmux, id_b_Y);
        index_20[key].push_back(value);
        }
      } while (0);
      do {
        Cell *ffcemux = cell;
        index_22_value_type value;
        std::get<0>(value) = cell;
        if (!(ffcemux->type.in(id_d_mux))) continue;
        vector<IdString> _pmg_choices_AB = {id_b_A, id_b_B};
        for (const IdString &AB : _pmg_choices_AB) {
        std::get<1>(value) = AB;
        bool &pol = std::get<2>(value);
        pol = (AB == id_b_A);
        index_22_key_type key;
        std::get<0>(key) = port(ffcemux, id_b_Y);
        std::get<1>(key) = port(ffcemux, AB);
        index_22[key].push_back(value);
        }
      } while (0);
      do {
        Cell *ffcemux = cell;
        index_26_value_type value;
        std::get<0>(value) = cell;
        if (!(ffcemux->type.in(id_d_mux))) continue;
        if (!(nusers(port(ffcemux, id_b_Y)) == 2)) continue;
        vector<IdString> _pmg_choices_AB = {id_b_A, id_b_B};
        for (const IdString &AB : _pmg_choices_AB) {
        std::get<1>(value) = AB;
        if (!(nusers(port(ffcemux, AB)) >= 3)) continue;
        int &offset = std::get<2>(value);
        for (offset = 0; offset < GetSize(port(ffcemux, id_b_Y)); offset++) {
        IdString &BA = std::get<3>(value);
        BA = (AB == id_b_A ? id_b_B : id_b_A);
        bool &pol = std::get<4>(value);
        pol = (AB == id_b_A);
        index_26_key_type key;
        std::get<0>(key) = port(ffcemux, BA)[offset];
        index_26[key].push_back(value);
        }
        }
      } while (0);
      do {
        Cell *ffrstmux = cell;
        index_28_value_type value;
        std::get<0>(value) = cell;
        if (!(ffrstmux->type.in(id_d_mux))) continue;
        if (!(nusers(port(ffrstmux, id_b_Y)) == 2)) continue;
        vector<IdString> _pmg_choices_BA = {id_b_B, id_b_A};
        for (const IdString &BA : _pmg_choices_BA) {
        std::get<1>(value) = BA;
        if (!(port(ffrstmux, BA).is_fully_zero())) continue;
        int &offset = std::get<2>(value);
        for (offset = 0; offset < GetSize(port(ffrstmux, id_b_Y)); offset++) {
        IdString &AB = std::get<3>(value);
        AB = (BA == id_b_B ? id_b_A : id_b_B);
        bool &pol = std::get<4>(value);
        pol = (AB == id_b_A);
        index_28_key_type key;
        std::get<0>(key) = port(ffrstmux, AB)[offset];
        index_28[key].push_back(value);
        }
        }
      } while (0);
      do {
        Cell *ff = cell;
        index_30_value_type value;
        std::get<0>(value) = cell;
        if (!(ff->type.in(id_d_dff))) continue;
        if (!(param(ff, id_b_CLK_POLARITY).as_bool())) continue;
        int &offset = std::get<1>(value);
        for (offset = 0; offset < GetSize(port(ff, id_b_D)); offset++) {
        index_30_key_type key;
        std::get<0>(key) = port(ff, id_b_D)[offset];
        index_30[key].push_back(value);
        }
      } while (0);
    }
  }

  ~xilinx_dsp_pm() {
    for (auto cell : autoremove_cells)
      module->remove(cell);
  }

  int run_xilinx_dsp_pack(std::function<void()> on_accept_f) {
    log_assert(setup_done);
    accept_cnt = 0;
    on_accept = on_accept_f;
    rollback = 0;
    st_xilinx_dsp_pack.argD = SigSpec();
    st_xilinx_dsp_pack.argQ = SigSpec();
    st_xilinx_dsp_pack.clock = SigBit();
    st_xilinx_dsp_pack.dsp = nullptr;
    st_xilinx_dsp_pack.ff = nullptr;
    st_xilinx_dsp_pack.ffA1 = nullptr;
    st_xilinx_dsp_pack.ffA1cemux = nullptr;
    st_xilinx_dsp_pack.ffA1cepol = bool();
    st_xilinx_dsp_pack.ffA1rstmux = nullptr;
    st_xilinx_dsp_pack.ffA2 = nullptr;
    st_xilinx_dsp_pack.ffA2cemux = nullptr;
    st_xilinx_dsp_pack.ffA2cepol = bool();
    st_xilinx_dsp_pack.ffA2rstmux = nullptr;
    st_xilinx_dsp_pack.ffAD = nullptr;
    st_xilinx_dsp_pack.ffADcemux = nullptr;
    st_xilinx_dsp_pack.ffADcepol = bool();
    st_xilinx_dsp_pack.ffADrstmux = nullptr;
    st_xilinx_dsp_pack.ffADrstpol = bool();
    st_xilinx_dsp_pack.ffArstpol = bool();
    st_xilinx_dsp_pack.ffB1 = nullptr;
    st_xilinx_dsp_pack.ffB1cemux = nullptr;
    st_xilinx_dsp_pack.ffB1cepol = bool();
    st_xilinx_dsp_pack.ffB1rstmux = nullptr;
    st_xilinx_dsp_pack.ffB2 = nullptr;
    st_xilinx_dsp_pack.ffB2cemux = nullptr;
    st_xilinx_dsp_pack.ffB2cepol = bool();
    st_xilinx_dsp_pack.ffB2rstmux = nullptr;
    st_xilinx_dsp_pack.ffBrstpol = bool();
    st_xilinx_dsp_pack.ffD = nullptr;
    st_xilinx_dsp_pack.ffDcemux = nullptr;
    st_xilinx_dsp_pack.ffDcepol = bool();
    st_xilinx_dsp_pack.ffDrstmux = nullptr;
    st_xilinx_dsp_pack.ffDrstpol = bool();
    st_xilinx_dsp_pack.ffM = nullptr;
    st_xilinx_dsp_pack.ffMcemux = nullptr;
    st_xilinx_dsp_pack.ffMcepol = bool();
    st_xilinx_dsp_pack.ffMrstmux = nullptr;
    st_xilinx_dsp_pack.ffMrstpol = bool();
    st_xilinx_dsp_pack.ffP = nullptr;
    st_xilinx_dsp_pack.ffPcemux = nullptr;
    st_xilinx_dsp_pack.ffPcepol = bool();
    st_xilinx_dsp_pack.ffPrstmux = nullptr;
    st_xilinx_dsp_pack.ffPrstpol = bool();
    st_xilinx_dsp_pack.ffcemux = nullptr;
    st_xilinx_dsp_pack.ffcepol = bool();
    st_xilinx_dsp_pack.ffoffset = int();
    st_xilinx_dsp_pack.ffrstmux = nullptr;
    st_xilinx_dsp_pack.ffrstpol = bool();
    st_xilinx_dsp_pack.overflow = nullptr;
    st_xilinx_dsp_pack.postAdd = nullptr;
    st_xilinx_dsp_pack.postAddAB = IdString();
    st_xilinx_dsp_pack.postAddMux = nullptr;
    st_xilinx_dsp_pack.postAddMuxAB = IdString();
    st_xilinx_dsp_pack.preAdd = nullptr;
    st_xilinx_dsp_pack.sigA = SigSpec();
    st_xilinx_dsp_pack.sigB = SigSpec();
    st_xilinx_dsp_pack.sigC = SigSpec();
    st_xilinx_dsp_pack.sigD = SigSpec();
    st_xilinx_dsp_pack.sigM = SigSpec();
    st_xilinx_dsp_pack.sigP = SigSpec();
    block_0(1);
    log_assert(rollback_cache.empty());
    return accept_cnt;
  }

  int run_xilinx_dsp_pack(std::function<void(xilinx_dsp_pm&)> on_accept_f) {
    return run_xilinx_dsp_pack([&](){on_accept_f(*this);});
  }

  int run_xilinx_dsp_pack() {
    return run_xilinx_dsp_pack([](){});
  }

  void block_subpattern_xilinx_dsp_pack_(int recursion) { block_0(recursion); }
  void block_subpattern_xilinx_dsp_pack_in_dffe(int recursion) { block_17(recursion); }
  void block_subpattern_xilinx_dsp_pack_out_dffe(int recursion) { block_25(recursion); }

  // passes/pmgen/xilinx_dsp.pmg:76
  void block_0(int recursion YS_ATTRIBUTE(unused)) {
    Cell* &dsp YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.dsp;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;
    Cell* _pmg_backup_dsp = dsp;

    index_0_key_type key;
    auto cells_ptr = index_0.find(key);

    if (cells_ptr != index_0.end()) {
      const vector<index_0_value_type> &cells = cells_ptr->second;
      for (int _pmg_idx = 0; _pmg_idx < GetSize(cells); _pmg_idx++) {
        dsp = std::get<0>(cells[_pmg_idx]);
        if (blacklist_cells.count(dsp)) continue;
        auto rollback_ptr = rollback_cache.insert(make_pair(std::get<0>(cells[_pmg_idx]), recursion));
        block_1(recursion+1);
        if (rollback_ptr.second)
          rollback_cache.erase(rollback_ptr.first);
        if (rollback) {
          if (rollback != recursion) {
            dsp = _pmg_backup_dsp;
            return;
          }
          rollback = 0;
        }
      }
    }

    dsp = nullptr;
    dsp = _pmg_backup_dsp;
  }

  // passes/pmgen/xilinx_dsp.pmg:80
  void block_1(int recursion YS_ATTRIBUTE(unused)) {
    Cell* const &dsp YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.dsp;
    SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    SigSpec &sigA YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigA;
    SigSpec &sigB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigB;
    SigSpec &sigC YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigC;
    SigSpec &sigD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigD;
    SigSpec &sigM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigM;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_2(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_xilinx_dsp_pack_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    auto unextend = [](const SigSpec &sig) {
      int i;
      for (i = GetSize(sig)-1; i > 0; i--)
        if (sig[i] != sig[i-1])
          break;
      // Do not remove non-const sign bit
      if (sig[i].wire)
        ++i;
      return sig.extract(0, i);
    };
    sigA = unextend(port(dsp, id_b_A));
    sigB = unextend(port(dsp, id_b_B));
    sigC = port(dsp, id_b_C, SigSpec());
    sigD = port(dsp, id_b_D, SigSpec());
    SigSpec P = port(dsp, id_b_P);
    if (param(dsp, id_b_USE_MULT, Const("MULTIPLY")).decode_string() == "MULTIPLY") {
      // Only care about those bits that are used
      int i;
      for (i = GetSize(P)-1; i >= 0; i--)
        if (nusers(P[i]) > 1)
          break;
      i++;
      log_assert(nusers(P.extract_end(i)) <= 1);
      // This sigM could have no users if downstream sinks (e.g. id_d_add) is
      //   narrower than id_d_mul result, for example
      if (i == 0)
        reject;
      sigM = P.extract(0, i);
    }
    else
      sigM = P;
    clock = port(dsp, id_b_CLK, SigBit());

    block_2(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_ATTRIBUTE(unused);

    clock = SigBit();
    sigA = SigSpec();
    sigB = SigSpec();
    sigC = SigSpec();
    sigD = SigSpec();
    sigM = SigSpec();
  }

  // passes/pmgen/xilinx_dsp.pmg:122
  void block_2(int recursion YS_ATTRIBUTE(unused)) {
    Cell* const &dsp YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.dsp;
    const SigSpec &sigB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigB;
    const SigSpec &sigC YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigC;
    const SigSpec &sigD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigD;
    const SigSpec &sigM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigM;
    SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* &ffAD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffAD;
    Cell* &ffADcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcemux;
    bool &ffADcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcepol;
    Cell* &ffADrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstmux;
    bool &ffADrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstpol;
    SigSpec &sigA YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigA;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;

    SigBit _pmg_backup_clock = clock;
    SigSpec _pmg_backup_sigA = sigA;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_3(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_xilinx_dsp_pack_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    if (param(dsp, id_b_ADREG).as_int() == 0) {
      argQ = sigA;
      subpattern(in_dffe);
      if (dff) {
        ffAD = dff;
        clock = dffclock;
        if (dffrstmux) {
          ffADrstmux = dffrstmux;
          ffADrstpol = dffrstpol;
        }
        if (dffcemux) {
          ffADcemux = dffcemux;
          ffADcepol = dffcepol;
        }
        sigA = dffD;
      }
    }

    block_3(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_ATTRIBUTE(unused);

    clock = _pmg_backup_clock;
    sigA = _pmg_backup_sigA;
    argQ = SigSpec();
    ffAD = nullptr;
    ffADcemux = nullptr;
    ffADcepol = bool();
    ffADrstmux = nullptr;
    ffADrstpol = bool();
  }

  // passes/pmgen/xilinx_dsp.pmg:144
  void block_3(int recursion YS_ATTRIBUTE(unused)) {
    const SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    const SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* const &dsp YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.dsp;
    Cell* const &ffAD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffAD;
    Cell* const &ffADcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcemux;
    const bool &ffADcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcepol;
    Cell* const &ffADrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstmux;
    const bool &ffADrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstpol;
    const SigSpec &sigA YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigA;
    const SigSpec &sigB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigB;
    const SigSpec &sigC YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigC;
    const SigSpec &sigD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigD;
    const SigSpec &sigM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigM;
    Cell* &preAdd YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.preAdd;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;
    Cell* _pmg_backup_preAdd = preAdd;

    if (!(sigD.empty() || sigD.is_fully_zero())) {
      preAdd = nullptr;
      block_4(recursion+1);
      preAdd = _pmg_backup_preAdd;
      return;
    }

    if (!(param(dsp, id_b_USE_DPORT, Const("FALSE")).decode_string() == "FALSE")) {
      preAdd = nullptr;
      block_4(recursion+1);
      preAdd = _pmg_backup_preAdd;
      return;
    }

    if (!(port(dsp, id_b_INMODE, Const(0, 5)).is_fully_zero())) {
      preAdd = nullptr;
      block_4(recursion+1);
      preAdd = _pmg_backup_preAdd;
      return;
    }

    index_3_key_type key;
    std::get<0>(key) = sigA;
    auto cells_ptr = index_3.find(key);

    if (cells_ptr != index_3.end()) {
      const vector<index_3_value_type> &cells = cells_ptr->second;
      for (int _pmg_idx = 0; _pmg_idx < GetSize(cells); _pmg_idx++) {
        preAdd = std::get<0>(cells[_pmg_idx]);
        const IdString &AB YS_ATTRIBUTE(unused) = std::get<1>(cells[_pmg_idx]);
        const IdString &BA YS_ATTRIBUTE(unused) = std::get<2>(cells[_pmg_idx]);
        if (blacklist_cells.count(preAdd)) continue;
        auto rollback_ptr = rollback_cache.insert(make_pair(std::get<0>(cells[_pmg_idx]), recursion));
        block_4(recursion+1);
        if (rollback_ptr.second)
          rollback_cache.erase(rollback_ptr.first);
        if (rollback) {
          if (rollback != recursion) {
            preAdd = _pmg_backup_preAdd;
            return;
          }
          rollback = 0;
        }
      }
    }

    preAdd = nullptr;
    block_4(recursion+1);
    preAdd = _pmg_backup_preAdd;
  }

  // passes/pmgen/xilinx_dsp.pmg:165
  void block_4(int recursion YS_ATTRIBUTE(unused)) {
    const SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    const SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* const &dsp YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.dsp;
    Cell* const &ffAD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffAD;
    Cell* const &ffADcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcemux;
    const bool &ffADcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcepol;
    Cell* const &ffADrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstmux;
    const bool &ffADrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstpol;
    Cell* const &preAdd YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.preAdd;
    const SigSpec &sigB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigB;
    const SigSpec &sigC YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigC;
    const SigSpec &sigM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigM;
    SigSpec &sigA YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigA;
    SigSpec &sigD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigD;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;

    SigSpec _pmg_backup_sigA = sigA;
    SigSpec _pmg_backup_sigD = sigD;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_5(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_xilinx_dsp_pack_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    if (preAdd) {
      sigA = port(preAdd, id_b_A);
      sigD = port(preAdd, id_b_B);
    }

    block_5(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_ATTRIBUTE(unused);

    sigA = _pmg_backup_sigA;
    sigD = _pmg_backup_sigD;
  }

  // passes/pmgen/xilinx_dsp.pmg:175
  void block_5(int recursion YS_ATTRIBUTE(unused)) {
    Cell* const &dsp YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.dsp;
    Cell* const &preAdd YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.preAdd;
    const SigSpec &sigB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigB;
    const SigSpec &sigC YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigC;
    const SigSpec &sigD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigD;
    const SigSpec &sigM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigM;
    SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* &ffA1 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1;
    Cell* &ffA1cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1cemux;
    bool &ffA1cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1cepol;
    Cell* &ffA1rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1rstmux;
    Cell* &ffA2 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2;
    Cell* &ffA2cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2cemux;
    bool &ffA2cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2cepol;
    Cell* &ffA2rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2rstmux;
    Cell* &ffAD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffAD;
    Cell* &ffADcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcemux;
    bool &ffADcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcepol;
    Cell* &ffADrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstmux;
    bool &ffADrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstpol;
    bool &ffArstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffArstpol;
    SigSpec &sigA YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigA;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;

    SigSpec _pmg_backup_argQ = argQ;
    SigBit _pmg_backup_clock = clock;
    Cell* _pmg_backup_ffAD = ffAD;
    Cell* _pmg_backup_ffADcemux = ffADcemux;
    bool _pmg_backup_ffADcepol = ffADcepol;
    Cell* _pmg_backup_ffADrstmux = ffADrstmux;
    bool _pmg_backup_ffADrstpol = ffADrstpol;
    SigSpec _pmg_backup_sigA = sigA;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_6(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_xilinx_dsp_pack_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    // Only search for ffA2 if there was a pre-adder
    //   (otherwise ffA2 would have been matched as ffAD)
    if (preAdd) {
      if (param(dsp, id_b_AREG).as_int() == 0) {
        argQ = sigA;
        subpattern(in_dffe);
        if (dff) {
          ffA2 = dff;
          clock = dffclock;
          if (dffrstmux) {
            ffA2rstmux = dffrstmux;
            ffArstpol = dffrstpol;
          }
          if (dffcemux) {
            ffA2cepol = dffcepol;
            ffA2cemux = dffcemux;
          }
          sigA = dffD;
        }
      }
    }
    // And if there wasn't a pre-adder,
    //   move AD register to A
    else if (ffAD) {
      log_assert(!ffA2 && !ffA2cemux && !ffA2rstmux);
      std::swap(ffA2, ffAD);
      std::swap(ffA2cemux, ffADcemux);
      std::swap(ffA2rstmux, ffADrstmux);
      ffA2cepol = ffADcepol;
      ffArstpol = ffADrstpol;
    }
    // Now attempt to match A1
    if (ffA2) {
      argQ = sigA;
      subpattern(in_dffe);
      if (dff) {
        if ((ffA2rstmux != nullptr) ^ (dffrstmux != nullptr))
          goto ffA1_end;
        if (dffrstmux) {
          if (ffArstpol != dffrstpol)
            goto ffA1_end;
          if (port(ffA2rstmux, id_b_S) != port(dffrstmux, id_b_S))
            goto ffA1_end;
          ffA1rstmux = dffrstmux;
        }
        ffA1 = dff;
        clock = dffclock;
        if (dffcemux) {
          ffA1cemux = dffcemux;
          ffA1cepol = dffcepol;
        }
        sigA = dffD;
  ffA1_end:    ;
      }
    }

    block_6(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_ATTRIBUTE(unused);

    argQ = _pmg_backup_argQ;
    clock = _pmg_backup_clock;
    ffAD = _pmg_backup_ffAD;
    ffADcemux = _pmg_backup_ffADcemux;
    ffADcepol = _pmg_backup_ffADcepol;
    ffADrstmux = _pmg_backup_ffADrstmux;
    ffADrstpol = _pmg_backup_ffADrstpol;
    sigA = _pmg_backup_sigA;
    ffA1 = nullptr;
    ffA1cemux = nullptr;
    ffA1cepol = bool();
    ffA1rstmux = nullptr;
    ffA2 = nullptr;
    ffA2cemux = nullptr;
    ffA2cepol = bool();
    ffA2rstmux = nullptr;
    ffArstpol = bool();
  }

  // passes/pmgen/xilinx_dsp.pmg:239
  void block_6(int recursion YS_ATTRIBUTE(unused)) {
    Cell* const &dsp YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.dsp;
    Cell* const &ffA1 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1;
    Cell* const &ffA1cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1cemux;
    const bool &ffA1cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1cepol;
    Cell* const &ffA1rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1rstmux;
    Cell* const &ffA2 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2;
    Cell* const &ffA2cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2cemux;
    const bool &ffA2cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2cepol;
    Cell* const &ffA2rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2rstmux;
    Cell* const &ffAD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffAD;
    Cell* const &ffADcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcemux;
    const bool &ffADcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcepol;
    Cell* const &ffADrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstmux;
    const bool &ffADrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstpol;
    const bool &ffArstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffArstpol;
    Cell* const &preAdd YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.preAdd;
    const SigSpec &sigA YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigA;
    const SigSpec &sigC YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigC;
    const SigSpec &sigD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigD;
    const SigSpec &sigM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigM;
    SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* &ffB1 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1;
    Cell* &ffB1cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1cemux;
    bool &ffB1cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1cepol;
    Cell* &ffB1rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1rstmux;
    Cell* &ffB2 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2;
    Cell* &ffB2cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2cemux;
    bool &ffB2cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2cepol;
    Cell* &ffB2rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2rstmux;
    bool &ffBrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffBrstpol;
    SigSpec &sigB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigB;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;

    SigSpec _pmg_backup_argQ = argQ;
    SigBit _pmg_backup_clock = clock;
    SigSpec _pmg_backup_sigB = sigB;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_7(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_xilinx_dsp_pack_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    if (param(dsp, id_b_BREG).as_int() == 0) {
      argQ = sigB;
      subpattern(in_dffe);
      if (dff) {
        ffB2 = dff;
        clock = dffclock;
        if (dffrstmux) {
          ffB2rstmux = dffrstmux;
          ffBrstpol = dffrstpol;
        }
        if (dffcemux) {
          ffB2cemux = dffcemux;
          ffB2cepol = dffcepol;
        }
        sigB = dffD;
        // Now attempt to match B1
        if (ffB2) {
          argQ = sigB;
          subpattern(in_dffe);
          if (dff) {
            if ((ffB2rstmux != nullptr) ^ (dffrstmux != nullptr))
              goto ffB1_end;
            if (dffrstmux) {
              if (ffBrstpol != dffrstpol)
                goto ffB1_end;
              if (port(ffB2rstmux, id_b_S) != port(dffrstmux, id_b_S))
                goto ffB1_end;
              ffB1rstmux = dffrstmux;
            }
            ffB1 = dff;
            clock = dffclock;
            if (dffcemux) {
              ffB1cemux = dffcemux;
              ffB1cepol = dffcepol;
            }
            sigB = dffD;
  ffB1_end:        ;
          }
        }
      }
    }

    block_7(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_ATTRIBUTE(unused);

    argQ = _pmg_backup_argQ;
    clock = _pmg_backup_clock;
    sigB = _pmg_backup_sigB;
    ffB1 = nullptr;
    ffB1cemux = nullptr;
    ffB1cepol = bool();
    ffB1rstmux = nullptr;
    ffB2 = nullptr;
    ffB2cemux = nullptr;
    ffB2cepol = bool();
    ffB2rstmux = nullptr;
    ffBrstpol = bool();
  }

  // passes/pmgen/xilinx_dsp.pmg:289
  void block_7(int recursion YS_ATTRIBUTE(unused)) {
    Cell* const &dsp YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.dsp;
    Cell* const &ffA1 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1;
    Cell* const &ffA1cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1cemux;
    const bool &ffA1cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1cepol;
    Cell* const &ffA1rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1rstmux;
    Cell* const &ffA2 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2;
    Cell* const &ffA2cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2cemux;
    const bool &ffA2cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2cepol;
    Cell* const &ffA2rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2rstmux;
    Cell* const &ffAD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffAD;
    Cell* const &ffADcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcemux;
    const bool &ffADcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcepol;
    Cell* const &ffADrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstmux;
    const bool &ffADrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstpol;
    const bool &ffArstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffArstpol;
    Cell* const &ffB1 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1;
    Cell* const &ffB1cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1cemux;
    const bool &ffB1cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1cepol;
    Cell* const &ffB1rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1rstmux;
    Cell* const &ffB2 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2;
    Cell* const &ffB2cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2cemux;
    const bool &ffB2cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2cepol;
    Cell* const &ffB2rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2rstmux;
    const bool &ffBrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffBrstpol;
    Cell* const &preAdd YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.preAdd;
    const SigSpec &sigA YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigA;
    const SigSpec &sigB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigB;
    const SigSpec &sigC YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigC;
    const SigSpec &sigM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigM;
    SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* &ffD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffD;
    Cell* &ffDcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDcemux;
    bool &ffDcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDcepol;
    Cell* &ffDrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDrstmux;
    bool &ffDrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDrstpol;
    SigSpec &sigD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigD;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;

    SigSpec _pmg_backup_argQ = argQ;
    SigBit _pmg_backup_clock = clock;
    SigSpec _pmg_backup_sigD = sigD;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_8(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_xilinx_dsp_pack_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    if (param(dsp, id_b_DREG).as_int() == 0) {
      argQ = sigD;
      subpattern(in_dffe);
      if (dff) {
        ffD = dff;
        clock = dffclock;
        if (dffrstmux) {
          ffDrstmux = dffrstmux;
          ffDrstpol = dffrstpol;
        }
        if (dffcemux) {
          ffDcemux = dffcemux;
          ffDcepol = dffcepol;
        }
        sigD = dffD;
      }
    }

    block_8(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_ATTRIBUTE(unused);

    argQ = _pmg_backup_argQ;
    clock = _pmg_backup_clock;
    sigD = _pmg_backup_sigD;
    ffD = nullptr;
    ffDcemux = nullptr;
    ffDcepol = bool();
    ffDrstmux = nullptr;
    ffDrstpol = bool();
  }

  // passes/pmgen/xilinx_dsp.pmg:310
  void block_8(int recursion YS_ATTRIBUTE(unused)) {
    const SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    Cell* const &dsp YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.dsp;
    Cell* const &ffA1 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1;
    Cell* const &ffA1cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1cemux;
    const bool &ffA1cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1cepol;
    Cell* const &ffA1rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1rstmux;
    Cell* const &ffA2 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2;
    Cell* const &ffA2cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2cemux;
    const bool &ffA2cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2cepol;
    Cell* const &ffA2rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2rstmux;
    Cell* const &ffAD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffAD;
    Cell* const &ffADcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcemux;
    const bool &ffADcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcepol;
    Cell* const &ffADrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstmux;
    const bool &ffADrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstpol;
    const bool &ffArstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffArstpol;
    Cell* const &ffB1 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1;
    Cell* const &ffB1cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1cemux;
    const bool &ffB1cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1cepol;
    Cell* const &ffB1rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1rstmux;
    Cell* const &ffB2 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2;
    Cell* const &ffB2cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2cemux;
    const bool &ffB2cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2cepol;
    Cell* const &ffB2rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2rstmux;
    const bool &ffBrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffBrstpol;
    Cell* const &ffD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffD;
    Cell* const &ffDcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDcemux;
    const bool &ffDcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDcepol;
    Cell* const &ffDrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDrstmux;
    const bool &ffDrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDrstpol;
    Cell* const &preAdd YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.preAdd;
    const SigSpec &sigA YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigA;
    const SigSpec &sigB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigB;
    const SigSpec &sigC YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigC;
    const SigSpec &sigD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigD;
    SigSpec &argD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argD;
    SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* &ffM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffM;
    Cell* &ffMcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMcemux;
    bool &ffMcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMcepol;
    Cell* &ffMrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMrstmux;
    bool &ffMrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMrstpol;
    SigSpec &sigM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigM;
    SigSpec &sigP YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigP;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;

    SigBit _pmg_backup_clock = clock;
    SigSpec _pmg_backup_sigM = sigM;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_9(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_xilinx_dsp_pack_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    if (param(dsp, id_b_MREG).as_int() == 0 && nusers(sigM) == 2) {
      argD = sigM;
      subpattern(out_dffe);
      if (dff) {
        ffM = dff;
        clock = dffclock;
        if (dffrstmux) {
          ffMrstmux = dffrstmux;
          ffMrstpol = dffrstpol;
        }
        if (dffcemux) {
          ffMcemux = dffcemux;
          ffMcepol = dffcepol;
        }
        sigM = dffQ;
      }
    }
    sigP = sigM;

    block_9(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_ATTRIBUTE(unused);

    clock = _pmg_backup_clock;
    sigM = _pmg_backup_sigM;
    argD = SigSpec();
    ffM = nullptr;
    ffMcemux = nullptr;
    ffMcepol = bool();
    ffMrstmux = nullptr;
    ffMrstpol = bool();
    sigP = SigSpec();
  }

  // passes/pmgen/xilinx_dsp.pmg:336
  void block_9(int recursion YS_ATTRIBUTE(unused)) {
    const SigSpec &argD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argD;
    const SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    const SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* const &dsp YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.dsp;
    Cell* const &ffA1 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1;
    Cell* const &ffA1cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1cemux;
    const bool &ffA1cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1cepol;
    Cell* const &ffA1rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1rstmux;
    Cell* const &ffA2 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2;
    Cell* const &ffA2cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2cemux;
    const bool &ffA2cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2cepol;
    Cell* const &ffA2rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2rstmux;
    Cell* const &ffAD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffAD;
    Cell* const &ffADcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcemux;
    const bool &ffADcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcepol;
    Cell* const &ffADrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstmux;
    const bool &ffADrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstpol;
    const bool &ffArstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffArstpol;
    Cell* const &ffB1 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1;
    Cell* const &ffB1cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1cemux;
    const bool &ffB1cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1cepol;
    Cell* const &ffB1rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1rstmux;
    Cell* const &ffB2 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2;
    Cell* const &ffB2cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2cemux;
    const bool &ffB2cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2cepol;
    Cell* const &ffB2rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2rstmux;
    const bool &ffBrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffBrstpol;
    Cell* const &ffD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffD;
    Cell* const &ffDcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDcemux;
    const bool &ffDcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDcepol;
    Cell* const &ffDrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDrstmux;
    const bool &ffDrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDrstpol;
    Cell* const &ffM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffM;
    Cell* const &ffMcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMcemux;
    const bool &ffMcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMcepol;
    Cell* const &ffMrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMrstmux;
    const bool &ffMrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMrstpol;
    Cell* const &preAdd YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.preAdd;
    const SigSpec &sigA YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigA;
    const SigSpec &sigB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigB;
    const SigSpec &sigC YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigC;
    const SigSpec &sigD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigD;
    const SigSpec &sigM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigM;
    const SigSpec &sigP YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigP;
    Cell* &postAdd YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.postAdd;
    IdString &postAddAB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.postAddAB;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;
    Cell* _pmg_backup_postAdd = postAdd;

    if (!(port(dsp, id_b_OPMODE, SigSpec()).extract(4,3).is_fully_zero())) {
      postAdd = nullptr;
      block_10(recursion+1);
      postAdd = _pmg_backup_postAdd;
      return;
    }

    index_9_key_type key;
    std::get<0>(key) = sigP[0];
    auto cells_ptr = index_9.find(key);

    if (cells_ptr != index_9.end()) {
      const vector<index_9_value_type> &cells = cells_ptr->second;
      for (int _pmg_idx = 0; _pmg_idx < GetSize(cells); _pmg_idx++) {
        postAdd = std::get<0>(cells[_pmg_idx]);
        const IdString &AB YS_ATTRIBUTE(unused) = std::get<1>(cells[_pmg_idx]);
        if (blacklist_cells.count(postAdd)) continue;
        if (!(ffMcemux || nusers(port(postAdd, AB)) == 2)) continue;
        if (!(!ffMcemux || nusers(port(postAdd, AB)) == 3)) continue;
        if (!(GetSize(port(postAdd, AB)) >= GetSize(sigP))) continue;
        if (!(port(postAdd, AB).extract(0, GetSize(sigP)) == sigP)) continue;
        if (!(port(postAdd, AB).extract_end(GetSize(sigP)) == SigSpec(sigP[GetSize(sigP)-1], GetSize(port(postAdd, AB))-GetSize(sigP)) || port(postAdd, AB).extract_end(GetSize(sigP)) == SigSpec(State::S0, GetSize(port(postAdd, AB))-GetSize(sigP)))) continue;
        auto _pmg_backup_postAddAB = postAddAB;
        postAddAB = AB;
        auto rollback_ptr = rollback_cache.insert(make_pair(std::get<0>(cells[_pmg_idx]), recursion));
        block_10(recursion+1);
        postAddAB = _pmg_backup_postAddAB;
        if (rollback_ptr.second)
          rollback_cache.erase(rollback_ptr.first);
        if (rollback) {
          if (rollback != recursion) {
            postAdd = _pmg_backup_postAdd;
            return;
          }
          rollback = 0;
        }
      }
    }

    postAdd = nullptr;
    block_10(recursion+1);
    postAdd = _pmg_backup_postAdd;
  }

  // passes/pmgen/xilinx_dsp.pmg:357
  void block_10(int recursion YS_ATTRIBUTE(unused)) {
    const SigSpec &argD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argD;
    const SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    const SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* const &dsp YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.dsp;
    Cell* const &ffA1 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1;
    Cell* const &ffA1cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1cemux;
    const bool &ffA1cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1cepol;
    Cell* const &ffA1rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1rstmux;
    Cell* const &ffA2 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2;
    Cell* const &ffA2cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2cemux;
    const bool &ffA2cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2cepol;
    Cell* const &ffA2rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2rstmux;
    Cell* const &ffAD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffAD;
    Cell* const &ffADcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcemux;
    const bool &ffADcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcepol;
    Cell* const &ffADrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstmux;
    const bool &ffADrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstpol;
    const bool &ffArstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffArstpol;
    Cell* const &ffB1 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1;
    Cell* const &ffB1cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1cemux;
    const bool &ffB1cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1cepol;
    Cell* const &ffB1rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1rstmux;
    Cell* const &ffB2 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2;
    Cell* const &ffB2cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2cemux;
    const bool &ffB2cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2cepol;
    Cell* const &ffB2rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2rstmux;
    const bool &ffBrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffBrstpol;
    Cell* const &ffD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffD;
    Cell* const &ffDcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDcemux;
    const bool &ffDcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDcepol;
    Cell* const &ffDrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDrstmux;
    const bool &ffDrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDrstpol;
    Cell* const &ffM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffM;
    Cell* const &ffMcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMcemux;
    const bool &ffMcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMcepol;
    Cell* const &ffMrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMrstmux;
    const bool &ffMrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMrstpol;
    Cell* const &postAdd YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.postAdd;
    const IdString &postAddAB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.postAddAB;
    Cell* const &preAdd YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.preAdd;
    const SigSpec &sigA YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigA;
    const SigSpec &sigB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigB;
    const SigSpec &sigD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigD;
    const SigSpec &sigM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigM;
    SigSpec &sigC YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigC;
    SigSpec &sigP YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigP;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;

    SigSpec _pmg_backup_sigC = sigC;
    SigSpec _pmg_backup_sigP = sigP;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_11(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_xilinx_dsp_pack_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    if (postAdd) {
      sigC = port(postAdd, postAddAB == id_b_A ? id_b_B : id_b_A);
      sigP = port(postAdd, id_b_Y);
    }

    block_11(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_ATTRIBUTE(unused);

    sigC = _pmg_backup_sigC;
    sigP = _pmg_backup_sigP;
  }

  // passes/pmgen/xilinx_dsp.pmg:365
  void block_11(int recursion YS_ATTRIBUTE(unused)) {
    const SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    Cell* const &dsp YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.dsp;
    Cell* const &ffA1 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1;
    Cell* const &ffA1cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1cemux;
    const bool &ffA1cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1cepol;
    Cell* const &ffA1rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1rstmux;
    Cell* const &ffA2 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2;
    Cell* const &ffA2cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2cemux;
    const bool &ffA2cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2cepol;
    Cell* const &ffA2rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2rstmux;
    Cell* const &ffAD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffAD;
    Cell* const &ffADcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcemux;
    const bool &ffADcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcepol;
    Cell* const &ffADrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstmux;
    const bool &ffADrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstpol;
    const bool &ffArstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffArstpol;
    Cell* const &ffB1 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1;
    Cell* const &ffB1cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1cemux;
    const bool &ffB1cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1cepol;
    Cell* const &ffB1rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1rstmux;
    Cell* const &ffB2 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2;
    Cell* const &ffB2cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2cemux;
    const bool &ffB2cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2cepol;
    Cell* const &ffB2rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2rstmux;
    const bool &ffBrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffBrstpol;
    Cell* const &ffD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffD;
    Cell* const &ffDcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDcemux;
    const bool &ffDcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDcepol;
    Cell* const &ffDrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDrstmux;
    const bool &ffDrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDrstpol;
    Cell* const &ffM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffM;
    Cell* const &ffMcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMcemux;
    const bool &ffMcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMcepol;
    Cell* const &ffMrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMrstmux;
    const bool &ffMrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMrstpol;
    Cell* const &postAdd YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.postAdd;
    const IdString &postAddAB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.postAddAB;
    Cell* const &preAdd YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.preAdd;
    const SigSpec &sigA YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigA;
    const SigSpec &sigB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigB;
    const SigSpec &sigC YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigC;
    const SigSpec &sigD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigD;
    const SigSpec &sigM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigM;
    SigSpec &argD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argD;
    SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* &ffP YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffP;
    Cell* &ffPcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffPcemux;
    bool &ffPcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffPcepol;
    Cell* &ffPrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffPrstmux;
    bool &ffPrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffPrstpol;
    SigSpec &sigP YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigP;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;

    SigSpec _pmg_backup_argD = argD;
    SigBit _pmg_backup_clock = clock;
    SigSpec _pmg_backup_sigP = sigP;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_12(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_xilinx_dsp_pack_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    if (param(dsp, id_b_PREG).as_int() == 0) {
      int users = 2;
      // If ffMcemux and no postAdd new-value net must have three users: ffMcemux, ffM and ffPcemux
      if (ffMcemux && !postAdd) users++;
      if (nusers(sigP) == users) {
        argD = sigP;
        subpattern(out_dffe);
        if (dff) {
          ffP = dff;
          clock = dffclock;
          if (dffrstmux) {
            ffPrstmux = dffrstmux;
            ffPrstpol = dffrstpol;
          }
          if (dffcemux) {
            ffPcemux = dffcemux;
            ffPcepol = dffcepol;
          }
          sigP = dffQ;
        }
      }
    }

    block_12(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_ATTRIBUTE(unused);

    argD = _pmg_backup_argD;
    clock = _pmg_backup_clock;
    sigP = _pmg_backup_sigP;
    ffP = nullptr;
    ffPcemux = nullptr;
    ffPcepol = bool();
    ffPrstmux = nullptr;
    ffPrstpol = bool();
  }

  // passes/pmgen/xilinx_dsp.pmg:403
  void block_12(int recursion YS_ATTRIBUTE(unused)) {
    const SigSpec &argD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argD;
    const SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    const SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* const &dsp YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.dsp;
    Cell* const &ffA1 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1;
    Cell* const &ffA1cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1cemux;
    const bool &ffA1cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1cepol;
    Cell* const &ffA1rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1rstmux;
    Cell* const &ffA2 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2;
    Cell* const &ffA2cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2cemux;
    const bool &ffA2cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2cepol;
    Cell* const &ffA2rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2rstmux;
    Cell* const &ffAD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffAD;
    Cell* const &ffADcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcemux;
    const bool &ffADcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcepol;
    Cell* const &ffADrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstmux;
    const bool &ffADrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstpol;
    const bool &ffArstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffArstpol;
    Cell* const &ffB1 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1;
    Cell* const &ffB1cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1cemux;
    const bool &ffB1cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1cepol;
    Cell* const &ffB1rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1rstmux;
    Cell* const &ffB2 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2;
    Cell* const &ffB2cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2cemux;
    const bool &ffB2cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2cepol;
    Cell* const &ffB2rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2rstmux;
    const bool &ffBrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffBrstpol;
    Cell* const &ffD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffD;
    Cell* const &ffDcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDcemux;
    const bool &ffDcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDcepol;
    Cell* const &ffDrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDrstmux;
    const bool &ffDrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDrstpol;
    Cell* const &ffM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffM;
    Cell* const &ffMcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMcemux;
    const bool &ffMcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMcepol;
    Cell* const &ffMrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMrstmux;
    const bool &ffMrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMrstpol;
    Cell* const &ffP YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffP;
    Cell* const &ffPcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffPcemux;
    const bool &ffPcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffPcepol;
    Cell* const &ffPrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffPrstmux;
    const bool &ffPrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffPrstpol;
    Cell* const &postAdd YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.postAdd;
    const IdString &postAddAB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.postAddAB;
    Cell* const &preAdd YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.preAdd;
    const SigSpec &sigA YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigA;
    const SigSpec &sigB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigB;
    const SigSpec &sigC YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigC;
    const SigSpec &sigD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigD;
    const SigSpec &sigM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigM;
    const SigSpec &sigP YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigP;
    Cell* &postAddMux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.postAddMux;
    IdString &postAddMuxAB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.postAddMuxAB;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;
    Cell* _pmg_backup_postAddMux = postAddMux;

    if (!(postAdd)) {
      postAddMux = nullptr;
      block_13(recursion+1);
      postAddMux = _pmg_backup_postAddMux;
      return;
    }

    if (!(ffP)) {
      postAddMux = nullptr;
      block_13(recursion+1);
      postAddMux = _pmg_backup_postAddMux;
      return;
    }

    index_12_key_type key;
    std::get<0>(key) = sigP;
    std::get<1>(key) = sigC;
    auto cells_ptr = index_12.find(key);

    if (cells_ptr != index_12.end()) {
      const vector<index_12_value_type> &cells = cells_ptr->second;
      for (int _pmg_idx = 0; _pmg_idx < GetSize(cells); _pmg_idx++) {
        postAddMux = std::get<0>(cells[_pmg_idx]);
        const IdString &AB YS_ATTRIBUTE(unused) = std::get<1>(cells[_pmg_idx]);
        if (blacklist_cells.count(postAddMux)) continue;
        auto _pmg_backup_postAddMuxAB = postAddMuxAB;
        postAddMuxAB = AB;
        auto rollback_ptr = rollback_cache.insert(make_pair(std::get<0>(cells[_pmg_idx]), recursion));
        block_13(recursion+1);
        postAddMuxAB = _pmg_backup_postAddMuxAB;
        if (rollback_ptr.second)
          rollback_cache.erase(rollback_ptr.first);
        if (rollback) {
          if (rollback != recursion) {
            postAddMux = _pmg_backup_postAddMux;
            return;
          }
          rollback = 0;
        }
      }
    }

    postAddMux = nullptr;
    block_13(recursion+1);
    postAddMux = _pmg_backup_postAddMux;
  }

  // passes/pmgen/xilinx_dsp.pmg:415
  void block_13(int recursion YS_ATTRIBUTE(unused)) {
    const SigSpec &argD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argD;
    const SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    const SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* const &dsp YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.dsp;
    Cell* const &ffA1 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1;
    Cell* const &ffA1cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1cemux;
    const bool &ffA1cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1cepol;
    Cell* const &ffA1rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1rstmux;
    Cell* const &ffA2 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2;
    Cell* const &ffA2cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2cemux;
    const bool &ffA2cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2cepol;
    Cell* const &ffA2rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2rstmux;
    Cell* const &ffAD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffAD;
    Cell* const &ffADcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcemux;
    const bool &ffADcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcepol;
    Cell* const &ffADrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstmux;
    const bool &ffADrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstpol;
    const bool &ffArstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffArstpol;
    Cell* const &ffB1 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1;
    Cell* const &ffB1cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1cemux;
    const bool &ffB1cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1cepol;
    Cell* const &ffB1rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1rstmux;
    Cell* const &ffB2 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2;
    Cell* const &ffB2cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2cemux;
    const bool &ffB2cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2cepol;
    Cell* const &ffB2rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2rstmux;
    const bool &ffBrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffBrstpol;
    Cell* const &ffD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffD;
    Cell* const &ffDcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDcemux;
    const bool &ffDcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDcepol;
    Cell* const &ffDrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDrstmux;
    const bool &ffDrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDrstpol;
    Cell* const &ffM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffM;
    Cell* const &ffMcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMcemux;
    const bool &ffMcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMcepol;
    Cell* const &ffMrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMrstmux;
    const bool &ffMrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMrstpol;
    Cell* const &ffP YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffP;
    Cell* const &ffPcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffPcemux;
    const bool &ffPcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffPcepol;
    Cell* const &ffPrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffPrstmux;
    const bool &ffPrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffPrstpol;
    Cell* const &postAdd YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.postAdd;
    const IdString &postAddAB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.postAddAB;
    Cell* const &postAddMux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.postAddMux;
    const IdString &postAddMuxAB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.postAddMuxAB;
    Cell* const &preAdd YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.preAdd;
    const SigSpec &sigA YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigA;
    const SigSpec &sigB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigB;
    const SigSpec &sigD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigD;
    const SigSpec &sigM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigM;
    const SigSpec &sigP YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigP;
    SigSpec &sigC YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigC;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;

    SigSpec _pmg_backup_sigC = sigC;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_14(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_xilinx_dsp_pack_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    if (postAddMux)
      sigC = port(postAddMux, postAddMuxAB == id_b_A ? id_b_B : id_b_A);

    block_14(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_ATTRIBUTE(unused);

    sigC = _pmg_backup_sigC;
  }

  // passes/pmgen/xilinx_dsp.pmg:425
  void block_14(int recursion YS_ATTRIBUTE(unused)) {
    const SigSpec &argD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argD;
    const SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    const SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* const &dsp YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.dsp;
    Cell* const &ffA1 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1;
    Cell* const &ffA1cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1cemux;
    const bool &ffA1cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1cepol;
    Cell* const &ffA1rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1rstmux;
    Cell* const &ffA2 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2;
    Cell* const &ffA2cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2cemux;
    const bool &ffA2cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2cepol;
    Cell* const &ffA2rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2rstmux;
    Cell* const &ffAD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffAD;
    Cell* const &ffADcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcemux;
    const bool &ffADcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcepol;
    Cell* const &ffADrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstmux;
    const bool &ffADrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstpol;
    const bool &ffArstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffArstpol;
    Cell* const &ffB1 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1;
    Cell* const &ffB1cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1cemux;
    const bool &ffB1cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1cepol;
    Cell* const &ffB1rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1rstmux;
    Cell* const &ffB2 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2;
    Cell* const &ffB2cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2cemux;
    const bool &ffB2cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2cepol;
    Cell* const &ffB2rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2rstmux;
    const bool &ffBrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffBrstpol;
    Cell* const &ffD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffD;
    Cell* const &ffDcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDcemux;
    const bool &ffDcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDcepol;
    Cell* const &ffDrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDrstmux;
    const bool &ffDrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDrstpol;
    Cell* const &ffM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffM;
    Cell* const &ffMcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMcemux;
    const bool &ffMcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMcepol;
    Cell* const &ffMrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMrstmux;
    const bool &ffMrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMrstpol;
    Cell* const &ffP YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffP;
    Cell* const &ffPcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffPcemux;
    const bool &ffPcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffPcepol;
    Cell* const &ffPrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffPrstmux;
    const bool &ffPrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffPrstpol;
    Cell* const &postAdd YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.postAdd;
    const IdString &postAddAB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.postAddAB;
    Cell* const &postAddMux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.postAddMux;
    const IdString &postAddMuxAB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.postAddMuxAB;
    Cell* const &preAdd YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.preAdd;
    const SigSpec &sigA YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigA;
    const SigSpec &sigB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigB;
    const SigSpec &sigC YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigC;
    const SigSpec &sigD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigD;
    const SigSpec &sigM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigM;
    const SigSpec &sigP YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigP;
    Cell* &overflow YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.overflow;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;
    Cell* _pmg_backup_overflow = overflow;

    if (!(ffP)) {
      overflow = nullptr;
      block_15(recursion+1);
      overflow = _pmg_backup_overflow;
      return;
    }

    if (!(param(dsp, id_b_USE_PATTERN_DETECT, Const("NO_PATDET")).decode_string() == "NO_PATDET")) {
      overflow = nullptr;
      block_15(recursion+1);
      overflow = _pmg_backup_overflow;
      return;
    }

    index_14_key_type key;
    std::get<0>(key) = sigP;
    auto cells_ptr = index_14.find(key);

    if (cells_ptr != index_14.end()) {
      const vector<index_14_value_type> &cells = cells_ptr->second;
      for (int _pmg_idx = 0; _pmg_idx < GetSize(cells); _pmg_idx++) {
        overflow = std::get<0>(cells[_pmg_idx]);
        const Const &B YS_ATTRIBUTE(unused) = std::get<1>(cells[_pmg_idx]);
        if (blacklist_cells.count(overflow)) continue;
        auto rollback_ptr = rollback_cache.insert(make_pair(std::get<0>(cells[_pmg_idx]), recursion));
        block_15(recursion+1);
        if (rollback_ptr.second)
          rollback_cache.erase(rollback_ptr.first);
        if (rollback) {
          if (rollback != recursion) {
            overflow = _pmg_backup_overflow;
            return;
          }
          rollback = 0;
        }
      }
    }

    overflow = nullptr;
    block_15(recursion+1);
    overflow = _pmg_backup_overflow;
  }

  // passes/pmgen/xilinx_dsp.pmg:437
  void block_15(int recursion YS_ATTRIBUTE(unused)) {
    const SigSpec &argD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argD;
    const SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    const SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* const &dsp YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.dsp;
    Cell* const &ffA1 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1;
    Cell* const &ffA1cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1cemux;
    const bool &ffA1cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1cepol;
    Cell* const &ffA1rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA1rstmux;
    Cell* const &ffA2 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2;
    Cell* const &ffA2cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2cemux;
    const bool &ffA2cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2cepol;
    Cell* const &ffA2rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffA2rstmux;
    Cell* const &ffAD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffAD;
    Cell* const &ffADcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcemux;
    const bool &ffADcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADcepol;
    Cell* const &ffADrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstmux;
    const bool &ffADrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffADrstpol;
    const bool &ffArstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffArstpol;
    Cell* const &ffB1 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1;
    Cell* const &ffB1cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1cemux;
    const bool &ffB1cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1cepol;
    Cell* const &ffB1rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB1rstmux;
    Cell* const &ffB2 YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2;
    Cell* const &ffB2cemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2cemux;
    const bool &ffB2cepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2cepol;
    Cell* const &ffB2rstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffB2rstmux;
    const bool &ffBrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffBrstpol;
    Cell* const &ffD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffD;
    Cell* const &ffDcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDcemux;
    const bool &ffDcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDcepol;
    Cell* const &ffDrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDrstmux;
    const bool &ffDrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffDrstpol;
    Cell* const &ffM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffM;
    Cell* const &ffMcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMcemux;
    const bool &ffMcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMcepol;
    Cell* const &ffMrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMrstmux;
    const bool &ffMrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffMrstpol;
    Cell* const &ffP YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffP;
    Cell* const &ffPcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffPcemux;
    const bool &ffPcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffPcepol;
    Cell* const &ffPrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffPrstmux;
    const bool &ffPrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffPrstpol;
    Cell* const &overflow YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.overflow;
    Cell* const &postAdd YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.postAdd;
    const IdString &postAddAB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.postAddAB;
    Cell* const &postAddMux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.postAddMux;
    const IdString &postAddMuxAB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.postAddMuxAB;
    Cell* const &preAdd YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.preAdd;
    const SigSpec &sigA YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigA;
    const SigSpec &sigB YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigB;
    const SigSpec &sigC YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigC;
    const SigSpec &sigD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigD;
    const SigSpec &sigM YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigM;
    const SigSpec &sigP YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.sigP;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_16(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_xilinx_dsp_pack_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    accept;

    block_16(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_ATTRIBUTE(unused);
  }

  void block_16(int recursion YS_ATTRIBUTE(unused)) {
  }

  // passes/pmgen/xilinx_dsp.pmg:461
  void block_17(int recursion YS_ATTRIBUTE(unused)) {
    const SigSpec &argD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argD;
    const SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    const SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_18(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_xilinx_dsp_pack_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    dff = nullptr;
    if (GetSize(argQ) == 0)
      reject;
    for (const auto &c : argQ.chunks()) {
      // Abandon matches when 'Q' is a constant
      if (!c.wire)
        reject;
      // Abandon matches when 'Q' has the keep attribute set
      if (c.wire->get_bool_attribute(id_b_keep))
        reject;
      // Abandon matches when 'Q' has a non-zero init attribute set
      // (not supported by DSP48E1)
      Const init = c.wire->attributes.at(id_b_init, Const());
      if (!init.empty())
        for (auto b : init.extract(c.offset, c.width))
          if (b != State::Sx && b != State::S0)
            reject;
    }

    block_18(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_ATTRIBUTE(unused);
  }

  // passes/pmgen/xilinx_dsp.pmg:484
  void block_18(int recursion YS_ATTRIBUTE(unused)) {
    const SigSpec &argD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argD;
    const SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    const SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* &ff YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ff;
    int &ffoffset YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffoffset;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;
    Cell* _pmg_backup_ff = ff;

    index_18_key_type key;
    std::get<0>(key) = argQ[0];
    auto cells_ptr = index_18.find(key);

    if (cells_ptr != index_18.end()) {
      const vector<index_18_value_type> &cells = cells_ptr->second;
      for (int _pmg_idx = 0; _pmg_idx < GetSize(cells); _pmg_idx++) {
        ff = std::get<0>(cells[_pmg_idx]);
        const int &offset YS_ATTRIBUTE(unused) = std::get<1>(cells[_pmg_idx]);
        if (blacklist_cells.count(ff)) continue;
        if (!(GetSize(port(ff, id_b_Q)) >= offset + GetSize(argQ))) continue;
        if (!(port(ff, id_b_Q).extract(offset, GetSize(argQ)) == argQ)) continue;
        if (!(clock == SigBit() || port(ff, id_b_CLK) == clock)) continue;
        auto _pmg_backup_ffoffset = ffoffset;
        ffoffset = offset;
        auto rollback_ptr = rollback_cache.insert(make_pair(std::get<0>(cells[_pmg_idx]), recursion));
        block_19(recursion+1);
        ffoffset = _pmg_backup_ffoffset;
        if (rollback_ptr.second)
          rollback_cache.erase(rollback_ptr.first);
        if (rollback) {
          if (rollback != recursion) {
            ff = _pmg_backup_ff;
            return;
          }
          rollback = 0;
        }
      }
    }

    ff = nullptr;
    ff = _pmg_backup_ff;
  }

  // passes/pmgen/xilinx_dsp.pmg:501
  void block_19(int recursion YS_ATTRIBUTE(unused)) {
    const SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* const &ff YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ff;
    const int &ffoffset YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffoffset;
    SigSpec &argD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argD;
    SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;

    SigSpec _pmg_backup_argD = argD;
    SigSpec _pmg_backup_argQ = argQ;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_20(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_xilinx_dsp_pack_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    SigSpec Q = port(ff, id_b_Q);
    dff = ff;
    dffclock = port(ff, id_b_CLK);
    dffD = argQ;
    argD = port(ff, id_b_D);
    argQ = Q;
    dffD.replace(argQ, argD);
    // Only search for ffrstmux if dffD only
    //   has two (ff, ffrstmux) users
    if (nusers(dffD) > 2)
      argD = SigSpec();

    block_20(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_ATTRIBUTE(unused);

    argD = _pmg_backup_argD;
    argQ = _pmg_backup_argQ;
  }

  // passes/pmgen/xilinx_dsp.pmg:518
  void block_20(int recursion YS_ATTRIBUTE(unused)) {
    const SigSpec &argD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argD;
    const SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    const SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* const &ff YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ff;
    const int &ffoffset YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffoffset;
    Cell* &ffrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffrstmux;
    bool &ffrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffrstpol;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;
    Cell* _pmg_backup_ffrstmux = ffrstmux;

    if (!(!argD.empty())) {
      ffrstmux = nullptr;
      block_21(recursion+1);
      ffrstmux = _pmg_backup_ffrstmux;
      return;
    }

    index_20_key_type key;
    std::get<0>(key) = argD;
    auto cells_ptr = index_20.find(key);
    bool found_any_match = false;

    if (cells_ptr != index_20.end()) {
      const vector<index_20_value_type> &cells = cells_ptr->second;
      for (int _pmg_idx = 0; _pmg_idx < GetSize(cells); _pmg_idx++) {
        ffrstmux = std::get<0>(cells[_pmg_idx]);
        const IdString &BA YS_ATTRIBUTE(unused) = std::get<1>(cells[_pmg_idx]);
        const bool &pol YS_ATTRIBUTE(unused) = std::get<2>(cells[_pmg_idx]);
        if (blacklist_cells.count(ffrstmux)) continue;
        found_any_match = true;
        auto _pmg_backup_ffrstpol = ffrstpol;
        ffrstpol = pol;
        auto rollback_ptr = rollback_cache.insert(make_pair(std::get<0>(cells[_pmg_idx]), recursion));
        block_21(recursion+1);
        ffrstpol = _pmg_backup_ffrstpol;
        if (rollback_ptr.second)
          rollback_cache.erase(rollback_ptr.first);
        if (rollback) {
          if (rollback != recursion) {
            ffrstmux = _pmg_backup_ffrstmux;
            return;
          }
          rollback = 0;
        }
      }
    }

    ffrstmux = nullptr;
    if (!found_any_match) block_21(recursion+1);
    ffrstmux = _pmg_backup_ffrstmux;
  }

  // passes/pmgen/xilinx_dsp.pmg:532
  void block_21(int recursion YS_ATTRIBUTE(unused)) {
    const SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    const SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* const &ff YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ff;
    const int &ffoffset YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffoffset;
    Cell* const &ffrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffrstmux;
    const bool &ffrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffrstpol;
    SigSpec &argD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argD;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;

    SigSpec _pmg_backup_argD = argD;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_22(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_xilinx_dsp_pack_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    if (ffrstmux) {
      dffrstmux = ffrstmux;
      dffrstpol = ffrstpol;
      argD = port(ffrstmux, ffrstpol ? id_b_A : id_b_B);
      dffD.replace(port(ffrstmux, id_b_Y), argD);
      // Only search for ffcemux if argQ has at
      //   least 3 users (ff, <upstream>, ffrstmux) and
      //   dffD only has two (ff, ffrstmux)
      if (!(nusers(argQ) >= 3 && nusers(dffD) == 2))
        argD = SigSpec();
    }
    else
      dffrstmux = nullptr;

    block_22(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_ATTRIBUTE(unused);

    argD = _pmg_backup_argD;
  }

  // passes/pmgen/xilinx_dsp.pmg:553
  void block_22(int recursion YS_ATTRIBUTE(unused)) {
    const SigSpec &argD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argD;
    const SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    const SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* const &ff YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ff;
    const int &ffoffset YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffoffset;
    Cell* const &ffrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffrstmux;
    const bool &ffrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffrstpol;
    Cell* &ffcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffcemux;
    bool &ffcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffcepol;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;
    Cell* _pmg_backup_ffcemux = ffcemux;

    if (!(!argD.empty())) {
      ffcemux = nullptr;
      block_23(recursion+1);
      ffcemux = _pmg_backup_ffcemux;
      return;
    }

    index_22_key_type key;
    std::get<0>(key) = argD;
    std::get<1>(key) = argQ;
    auto cells_ptr = index_22.find(key);
    bool found_any_match = false;

    if (cells_ptr != index_22.end()) {
      const vector<index_22_value_type> &cells = cells_ptr->second;
      for (int _pmg_idx = 0; _pmg_idx < GetSize(cells); _pmg_idx++) {
        ffcemux = std::get<0>(cells[_pmg_idx]);
        const IdString &AB YS_ATTRIBUTE(unused) = std::get<1>(cells[_pmg_idx]);
        const bool &pol YS_ATTRIBUTE(unused) = std::get<2>(cells[_pmg_idx]);
        if (blacklist_cells.count(ffcemux)) continue;
        found_any_match = true;
        auto _pmg_backup_ffcepol = ffcepol;
        ffcepol = pol;
        auto rollback_ptr = rollback_cache.insert(make_pair(std::get<0>(cells[_pmg_idx]), recursion));
        block_23(recursion+1);
        ffcepol = _pmg_backup_ffcepol;
        if (rollback_ptr.second)
          rollback_cache.erase(rollback_ptr.first);
        if (rollback) {
          if (rollback != recursion) {
            ffcemux = _pmg_backup_ffcemux;
            return;
          }
          rollback = 0;
        }
      }
    }

    ffcemux = nullptr;
    if (!found_any_match) block_23(recursion+1);
    ffcemux = _pmg_backup_ffcemux;
  }

  // passes/pmgen/xilinx_dsp.pmg:564
  void block_23(int recursion YS_ATTRIBUTE(unused)) {
    const SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    const SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* const &ff YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ff;
    Cell* const &ffcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffcemux;
    const bool &ffcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffcepol;
    const int &ffoffset YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffoffset;
    Cell* const &ffrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffrstmux;
    const bool &ffrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffrstpol;
    SigSpec &argD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argD;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;

    SigSpec _pmg_backup_argD = argD;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_24(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_xilinx_dsp_pack_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    if (ffcemux) {
      dffcemux = ffcemux;
      dffcepol = ffcepol;
      argD = port(ffcemux, ffcepol ? id_b_B : id_b_A);
      dffD.replace(port(ffcemux, id_b_Y), argD);
    }
    else
      dffcemux = nullptr;

    block_24(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_ATTRIBUTE(unused);

    argD = _pmg_backup_argD;
  }

  void block_24(int recursion YS_ATTRIBUTE(unused)) {
  }

  // passes/pmgen/xilinx_dsp.pmg:592
  void block_25(int recursion YS_ATTRIBUTE(unused)) {
    const SigSpec &argD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argD;
    const SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    const SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_26(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_xilinx_dsp_pack_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    dff = nullptr;
    for (auto c : argD.chunks())
      // Abandon matches when 'D' has the keep attribute set
      if (c.wire->get_bool_attribute(id_b_keep))
        reject;

    block_26(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_ATTRIBUTE(unused);
  }

  // passes/pmgen/xilinx_dsp.pmg:603
  void block_26(int recursion YS_ATTRIBUTE(unused)) {
    const SigSpec &argD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argD;
    const SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    const SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* &ffcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffcemux;
    bool &ffcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffcepol;
    int &ffoffset YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffoffset;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;
    Cell* _pmg_backup_ffcemux = ffcemux;

    index_26_key_type key;
    std::get<0>(key) = argD[0];
    auto cells_ptr = index_26.find(key);
    bool found_any_match = false;

    if (cells_ptr != index_26.end()) {
      const vector<index_26_value_type> &cells = cells_ptr->second;
      for (int _pmg_idx = 0; _pmg_idx < GetSize(cells); _pmg_idx++) {
        ffcemux = std::get<0>(cells[_pmg_idx]);
        const IdString &AB YS_ATTRIBUTE(unused) = std::get<1>(cells[_pmg_idx]);
        const int &offset YS_ATTRIBUTE(unused) = std::get<2>(cells[_pmg_idx]);
        const IdString &BA YS_ATTRIBUTE(unused) = std::get<3>(cells[_pmg_idx]);
        const bool &pol YS_ATTRIBUTE(unused) = std::get<4>(cells[_pmg_idx]);
        if (blacklist_cells.count(ffcemux)) continue;
        if (!(GetSize(port(ffcemux, BA)) >= offset + GetSize(argD))) continue;
        if (!(port(ffcemux, BA).extract(offset, GetSize(argD)) == argD)) continue;
        found_any_match = true;
        auto _pmg_backup_ffoffset = ffoffset;
        ffoffset = offset;
        auto _pmg_backup_ffcepol = ffcepol;
        ffcepol = pol;
        auto rollback_ptr = rollback_cache.insert(make_pair(std::get<0>(cells[_pmg_idx]), recursion));
        block_27(recursion+1);
        ffoffset = _pmg_backup_ffoffset;
        ffcepol = _pmg_backup_ffcepol;
        if (rollback_ptr.second)
          rollback_cache.erase(rollback_ptr.first);
        if (rollback) {
          if (rollback != recursion) {
            ffcemux = _pmg_backup_ffcemux;
            return;
          }
          rollback = 0;
        }
      }
    }

    ffcemux = nullptr;
    if (!found_any_match) block_27(recursion+1);
    ffcemux = _pmg_backup_ffcemux;
  }

  // passes/pmgen/xilinx_dsp.pmg:627
  void block_27(int recursion YS_ATTRIBUTE(unused)) {
    const SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* const &ffcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffcemux;
    const bool &ffcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffcepol;
    const int &ffoffset YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffoffset;
    SigSpec &argD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argD;
    SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;

    SigSpec _pmg_backup_argD = argD;
    SigSpec _pmg_backup_argQ = argQ;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_28(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_xilinx_dsp_pack_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    dffcemux = ffcemux;
    if (ffcemux) {
      SigSpec BA = port(ffcemux, ffcepol ? id_b_B : id_b_A);
      SigSpec Y = port(ffcemux, id_b_Y);
      argQ = argD;
      argD.replace(BA, Y);
      argQ.replace(BA, port(ffcemux, ffcepol ? id_b_A : id_b_B));
      dffcemux = ffcemux;
      dffcepol = ffcepol;
    }

    block_28(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_ATTRIBUTE(unused);

    argD = _pmg_backup_argD;
    argQ = _pmg_backup_argQ;
  }

  // passes/pmgen/xilinx_dsp.pmg:645
  void block_28(int recursion YS_ATTRIBUTE(unused)) {
    const SigSpec &argD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argD;
    const SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    const SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* const &ffcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffcemux;
    const bool &ffcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffcepol;
    int &ffoffset YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffoffset;
    Cell* &ffrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffrstmux;
    bool &ffrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffrstpol;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;
    Cell* _pmg_backup_ffrstmux = ffrstmux;

    index_28_key_type key;
    std::get<0>(key) = argD[0];
    auto cells_ptr = index_28.find(key);
    bool found_any_match = false;

    if (cells_ptr != index_28.end()) {
      const vector<index_28_value_type> &cells = cells_ptr->second;
      for (int _pmg_idx = 0; _pmg_idx < GetSize(cells); _pmg_idx++) {
        ffrstmux = std::get<0>(cells[_pmg_idx]);
        const IdString &BA YS_ATTRIBUTE(unused) = std::get<1>(cells[_pmg_idx]);
        const int &offset YS_ATTRIBUTE(unused) = std::get<2>(cells[_pmg_idx]);
        const IdString &AB YS_ATTRIBUTE(unused) = std::get<3>(cells[_pmg_idx]);
        const bool &pol YS_ATTRIBUTE(unused) = std::get<4>(cells[_pmg_idx]);
        if (blacklist_cells.count(ffrstmux)) continue;
        if (!(!ffcemux || ffoffset == offset)) continue;
        if (!(GetSize(port(ffrstmux, AB)) >= offset + GetSize(argD))) continue;
        if (!(port(ffrstmux, AB).extract(offset, GetSize(argD)) == argD)) continue;
        found_any_match = true;
        auto _pmg_backup_ffoffset = ffoffset;
        ffoffset = offset;
        auto _pmg_backup_ffrstpol = ffrstpol;
        ffrstpol = pol;
        auto rollback_ptr = rollback_cache.insert(make_pair(std::get<0>(cells[_pmg_idx]), recursion));
        block_29(recursion+1);
        ffoffset = _pmg_backup_ffoffset;
        ffrstpol = _pmg_backup_ffrstpol;
        if (rollback_ptr.second)
          rollback_cache.erase(rollback_ptr.first);
        if (rollback) {
          if (rollback != recursion) {
            ffrstmux = _pmg_backup_ffrstmux;
            return;
          }
          rollback = 0;
        }
      }
    }

    ffrstmux = nullptr;
    if (!found_any_match) block_29(recursion+1);
    ffrstmux = _pmg_backup_ffrstmux;
  }

  // passes/pmgen/xilinx_dsp.pmg:671
  void block_29(int recursion YS_ATTRIBUTE(unused)) {
    const SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* const &ffcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffcemux;
    const bool &ffcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffcepol;
    const int &ffoffset YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffoffset;
    Cell* const &ffrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffrstmux;
    const bool &ffrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffrstpol;
    SigSpec &argD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argD;
    SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;

    SigSpec _pmg_backup_argD = argD;
    SigSpec _pmg_backup_argQ = argQ;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_30(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_xilinx_dsp_pack_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    dffrstmux = ffrstmux;
    if (ffrstmux) {
      SigSpec AB = port(ffrstmux, ffrstpol ? id_b_A : id_b_B);
      SigSpec Y = port(ffrstmux, id_b_Y);
      argD.replace(AB, Y);
      dffrstmux = ffrstmux;
      dffrstpol = ffrstpol;
    }

    block_30(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_ATTRIBUTE(unused);

    argD = _pmg_backup_argD;
    argQ = _pmg_backup_argQ;
  }

  // passes/pmgen/xilinx_dsp.pmg:685
  void block_30(int recursion YS_ATTRIBUTE(unused)) {
    const SigSpec &argD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argD;
    const SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    const SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* const &ffcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffcemux;
    const bool &ffcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffcepol;
    Cell* const &ffrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffrstmux;
    const bool &ffrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffrstpol;
    Cell* &ff YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ff;
    int &ffoffset YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffoffset;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;
    Cell* _pmg_backup_ff = ff;

    index_30_key_type key;
    std::get<0>(key) = argD[0];
    auto cells_ptr = index_30.find(key);

    if (cells_ptr != index_30.end()) {
      const vector<index_30_value_type> &cells = cells_ptr->second;
      for (int _pmg_idx = 0; _pmg_idx < GetSize(cells); _pmg_idx++) {
        ff = std::get<0>(cells[_pmg_idx]);
        const int &offset YS_ATTRIBUTE(unused) = std::get<1>(cells[_pmg_idx]);
        if (blacklist_cells.count(ff)) continue;
        if (!((!ffcemux && !ffrstmux) || ffoffset == offset)) continue;
        if (!(GetSize(port(ff, id_b_D)) >= offset + GetSize(argD))) continue;
        if (!(port(ff, id_b_D).extract(offset, GetSize(argD)) == argD)) continue;
        if (!(!ffcemux || port(ff, id_b_Q).extract(offset, GetSize(argQ)) == argQ)) continue;
        if (!(clock == SigBit() || port(ff, id_b_CLK) == clock)) continue;
        auto _pmg_backup_ffoffset = ffoffset;
        ffoffset = offset;
        auto rollback_ptr = rollback_cache.insert(make_pair(std::get<0>(cells[_pmg_idx]), recursion));
        block_31(recursion+1);
        ffoffset = _pmg_backup_ffoffset;
        if (rollback_ptr.second)
          rollback_cache.erase(rollback_ptr.first);
        if (rollback) {
          if (rollback != recursion) {
            ff = _pmg_backup_ff;
            return;
          }
          rollback = 0;
        }
      }
    }

    ff = nullptr;
    ff = _pmg_backup_ff;
  }

  // passes/pmgen/xilinx_dsp.pmg:706
  void block_31(int recursion YS_ATTRIBUTE(unused)) {
    const SigSpec &argD YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argD;
    const SigBit &clock YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.clock;
    Cell* const &ff YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ff;
    Cell* const &ffcemux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffcemux;
    const bool &ffcepol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffcepol;
    const int &ffoffset YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffoffset;
    Cell* const &ffrstmux YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffrstmux;
    const bool &ffrstpol YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.ffrstpol;
    SigSpec &argQ YS_ATTRIBUTE(unused) = st_xilinx_dsp_pack.argQ;
    Cell* &dff YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dff;
    SigSpec &dffD YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffD;
    SigSpec &dffQ YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffQ;
    Cell* &dffcemux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcemux;
    bool &dffcepol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffcepol;
    SigBit &dffclock YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffclock;
    Cell* &dffrstmux YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstmux;
    bool &dffrstpol YS_ATTRIBUTE(unused) = ud_xilinx_dsp_pack.dffrstpol;

    SigSpec _pmg_backup_argQ = argQ;

#define reject do { goto rollback_label; } while(0)
#define accept do { accept_cnt++; on_accept(); if (rollback) goto rollback_label; } while(0)
#define finish do { rollback = -1; goto rollback_label; } while(0)
#define branch do { block_32(recursion+1); if (rollback) goto rollback_label; } while(0)
#define subpattern(pattern_name) do { block_subpattern_xilinx_dsp_pack_ ## pattern_name (recursion+1); if (rollback) goto rollback_label; } while(0)
    SigSpec D = port(ff, id_b_D);
    SigSpec Q = port(ff, id_b_Q);
    if (!ffcemux) {
      argQ = argD;
      argQ.replace(D, Q);
    }
    // Abandon matches when 'Q' has a non-zero init attribute set
    // (not supported by DSP48E1)
    for (auto c : argQ.chunks()) {
      Const init = c.wire->attributes.at(id_b_init, Const());
      if (!init.empty())
        for (auto b : init.extract(c.offset, c.width))
          if (b != State::Sx && b != State::S0)
            reject;
    }
    dff = ff;
    dffQ = argQ;
    dffclock = port(ff, id_b_CLK);

    block_32(recursion+1);
#undef reject
#undef accept
#undef finish
#undef branch
#undef subpattern

rollback_label:
    YS_ATTRIBUTE(unused);

    argQ = _pmg_backup_argQ;
  }

  void block_32(int recursion YS_ATTRIBUTE(unused)) {
  }
};
